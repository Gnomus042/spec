<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>Shape Expressions ShExPath Language</title>
    <!-- link rel="stylesheet" href="css/wgio.min.css"/ ask Iovka -->
    <link rel="stylesheet" href="local.css"/>

    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            async="async" class='remove'></script>
    <script src="https://www.w3.org/2013/ShEx/demobits/jquery.min.js" type="text/javascript"></script>

    <script class='remove'>
      var respecConfig = {
      specStatus: "base",
      shortName:  "shexpath",
      editors: [
      {   name:       "Eric Prud'hommeaux",
      url:        "http://www.w3.org/Team/Eric",
      company:    "Janeiro Digital, Micelio" }
      ],
      // wg:           "Shape Expressions ",
      // wgURI:        "https://shex.io/",
      // wgPublicList: "public-shex-dev",
      // wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/424242/status",
      };
    </script>
    <style type="text/css">
      em { font-weight: bold; }
    </style>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        ShEx is a schema language for RDF graphs. It provides structural constraint on graph structures and lexical forms of literals.
        ShExPath addresses elements in a ShEx schema.
        This can be used to anchor validation results, identify regions of RDF graphs, or tie external annotations to elements in a schema.
      </p>
    </section>

    <section id="scope">
      <h2>Scope</h2>
      <p>
        ShExPath identifies <a href="">Shape Expressions</a> and <a href="">Triple Expressions</a>.
        It does not, on its own, identify portions of <a href="">Node Constraint</a>.
      </p>
    </section>

    <section id="data-model">
      <h2>Data Model</h2>
      <p>
        A ShExPath is a Unicode string which defines a traversal of a Shape Expressions schema.
      </p>
      <p>
        An <dfn>item</dfn> is one of these elements from a Shape Expressions schema:
      </p>
      <ul>
        <li>some shape expression:<ul>
        <li>a ShapeAnd expression</li>
        <li>a ShapeOr expression</li>
        <li>a ShapeNot expression</li>
        <li>a NodeConstraint</li>
        <li>a Shape</li>
      </ul>some triple expression<ul>
        <li>an EachOf triple expression</li>
        <li>a OneOf triple expression</li>
        <li>a Triple Constraint</li>
      </ul></li>
      </ul>
      <p>
        A <dfn>value</dfn> is a sequence of <a>items</a>.
      </p>
      <p>
        A <dfn>singleton</dfn> is a sequence of exactly one <a>item</a>.
      </p>
      <p class="issue">some way to say a singleton is expected? useful at end to say ShExPath should specify a single item; useful earlier in path for debugging.</p>
      <p>
        <dfn>evaluation</dfn>(path, schema, optional value) is a process that takes as arguments a schema <code>S</code> and a <a>value</a> and produces a <a>value</a>.
        The operators are evaluated as follows:
      .</p>
      <ul>
        <li>
          <code>/</code>: <code>value</code> = the list of shapes in the schema
        </li>
        <li>
          axis label (<code>shapeAnd::</code> | <code>shapeOr::</code> | <code>shapeNot::</code> | <code>eachOf::</code> | <code>oneOf::</code> | <code>NodeConstraint</code> | <code>TripleConstraint</code>): the items in <code>value</code> are tested for alignment with the axis label.
          It is a fatal error if the <code>item</code> is not the same as the axis label.
          This does not change the <code>value</code>.
          <p class="issue">is an error or just a filter?</p>
        </li>
        <li>
          <code>[index]/?</code>: <code>value</code> = a mapping of the <code>items</code> in <code>value</code> to<br/>
          switch <code>item</code>:
          <ul>
            <li>(ShapeAnd | ShapeOr) and index a 1-based integer: <code>item</code> = item.tripleExprs[index-1]</li>
            <li>(EachOf | OneOf) and index a 1-based integer: <code>item</code> = item.expressions[index-1]</li>
            <li>(EachOf | OneOf) and index a URL: <code>item</code> = item.expressions[index-1]</li>
          </ul>
          )
        </li>
        <li>
          <i>empty string</i>: the evaluation is terminated, the result is <code>value</code>.
        </li>
      </ul>
      <p class="todo">advance through ShapeAnd automagically? doubles threads?</p>
    </section>

    <section id="issueExample">
      <h2>Issue Example</h2>
      <p>
        This schema excerpt describes an issue that might appear in an issue tracking system. 
      </p>
      <pre>
&lt;#IssueShape> {
  :name STRING MinLength 4;
  :category ["bug" "feature request"];
  :postedBy @&lt;#UserShape>;
  :processing {
    :reproduced [true false];
    :priority xsd:integer
  }?
}

&lt;#UserShape> IRI /User\?id=[0-9]+/ {
  (  foaf:name xsd:string
   | foaf:givenName +;
     foaf:familyName            
  );
  foaf:mbox IRI
}
      </pre>
    </section>
      <section id="simple-access">
        <h2>Simple Access</h2>
        <p>
          Elements can be addressed either by label or index.
          For shape expressions, the label is the name of the shape expression.
          For triple constraints, the label is the name of the predicate for that triple constraints.
        </p>
      <table>
        <thead>
          <th>ShExPath</th> <th>value</th>
        </thead>
        <tbody>
          <tr><td>/[#IssueShape]/[:category]</td><td>the <code>:category</code> constraint in the <code>#IssueShape</code> shape, addressed by the <em>name</em> of the shape expression followed by the <em>name</em> of the <code>:category</code> property.</td></tr>
          <tr><td>/[#IssueShape]/[2]</td><td>the <code>:category</code> constraint in the <code>#IssueShape</code> shape, addressed by the <em>name</em> of the shape expression followed by the <em>index</em> of the <code>:category</code> property.</td></tr>
          <tr><td>/[1]/[2]</td><td>the <code>:category</code> constraint in the <code>#IssueShape</code> shape, addressed by the <em>index</em> of the shape expression followed by the <em>index</em> of the <code>:category</code> property.</td></tr>
          <tr><td>/[#UserShape]/shapeAnd[2][foaf:mbox]</td><td>the <code>foaf:mbox</code> constraint in <code>#UserShape</code>'s shape.
          Note that <code>IRI /User\?id=[0-9]+/ {...}</code> compiles to a <code>ShapeAnd</code> with the first component a <code>NodeConstraint</code> and the second being a shape..
          </td></tr>
        </tbody>
      </table>
      </section>

      <section id="triple-expressions">
        <h2>Triple Expressions</h2>
        <p>
          Elements of triple expressions may be selected by index within the triple expression.
          For added clarity, the axes <code>eachOf</code> and <code>oneOf</code> may be used to specify the expected expression type.
          If the expression type is specified and does not match the corresponding type in the schema, the path is invalid.
        </p>
      <table>
        <thead>
          <th>ShExPath</th> <th>value</th>
        </thead>
        <tbody>
          <tr><td>/shapes[1]/shapeAnd[2]/eachOf[2]</td><td>the <code>:category</code> constraint in the <code>#IssueShape</code> shape, explicitly labeling the <em>index</em> axes.</td></tr>
          <tr><td>/[#UserShape][2]/eachOf::[1]/oneOf::[2]</td><td>the <code>EachOf</code> containing <code>foaf:givenName</code> and <code>foaf:familyName</code> in the <code>#UserShape</code> shape.</td></tr>
          <tr><td>/[#UserShape][2]/eachOf::[1]/eachOf::[2]</td><td class="error">invalid path for the given schema.</td></tr>
        </tbody>
      </table>
      </section>

      <section id="disambiguation">
        <h2>Disambiguation</h2>
        <p>
          If more than one triple constraint has the same predicate, they can be indexed by the order they would be encountered in a depth-first search.
        </p>
      </section>

      <section id="grammar">
        <h2>Grammar</h2>
        <p>
          [<a href="https://services.w3.org/yacker/uploads/ShExPath?lang=perl">Try it in yacker</a>].
        <pre>
ShExPathExpr             ::= AbsolutePathExpr | RelativePathExpr
AbsolutePathExpr         ::= "/" RelativePathExpr
RelativePathExpr         ::= StepExpr ("/" StepExpr)*
StepExpr                 ::= ContextTest? Index
ContextTest              ::= Context
Context                  ::= "shapeAnd" | "shapeOr" | "shapeNot"
                           | "nodeConstraint" | "shape"
                           | "eachOf" | "oneOf" | "tripleConstraint"
Index                    ::= "["? (INTEGER | schemaLabel INTEGER? ) "]"?
schemaLabel              ::= ShapeExprLabel | TripleExprLabel
ShapeExprLabel           ::= "@" (iri | BLANK_NODE_LABEL)
TripleExprLabel          ::= iri | BLANK_NODE_LABEL
[136s]  iri              ::= IRIREF | prefixedName
[137s]  prefixedName     ::= PNAME_LN | PNAME_NS

@terminals
[18t]   IRIREF           ::= '&lt;' ([^#x00-#x20<>\"{}|^`\\] | UCHAR)* '&gt;'
[140s]  PNAME_NS         ::= PN_PREFIX? ':'
[141s]  PNAME_LN         ::= PNAME_NS PN_LOCAL
[142s]  BLANK_NODE_LABEL ::= '_:' (PN_CHARS_U | [0-9]) ((PN_CHARS | '.')* PN_CHARS)?
[19t]   INTEGER          ::= [+-]? [0-9]+
[26t]   UCHAR            ::= '\\u' HEX HEX HEX HEX
                           | '\\U' HEX HEX HEX HEX HEX HEX HEX HEX
[160s]  ECHAR            ::= '\\' [tbnrf\\\"\']
[164s]  PN_CHARS_BASE    ::= [A-Z] | [a-z]
                           | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF]
                           | [#x0370-#x037D] | [#x037F-#x1FFF]
                           | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF]
                           | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD]
                           | [#x10000-#xEFFFF]
[165s]  PN_CHARS_U       ::= PN_CHARS_BASE | '_'
[167s]  PN_CHARS         ::= PN_CHARS_U | '-' | [0-9]
                           | [#x00B7] | [#x0300-#x036F] | [#x203F-#x2040]
[168s]  PN_PREFIX        ::= PN_CHARS_BASE ((PN_CHARS | '.')* PN_CHARS)?
[169s]  PN_LOCAL         ::= (PN_CHARS_U | ':' | [0-9] | PLX)
                             ((PN_CHARS | '.' | ':' | PLX)*
                             (PN_CHARS | ':' | PLX))?
[170s]  PLX              ::= PERCENT | PN_LOCAL_ESC
[171s]  PERCENT          ::= '%' HEX HEX
[172s]  HEX              ::= [0-9] | [A-F] | [a-f]
[173s]  PN_LOCAL_ESC     ::= '\\' ('_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'"
                           | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?'
                           | '#' | '@' | '%')
        </pre>
      </section>
  </body>
</html>
